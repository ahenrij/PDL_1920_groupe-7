<<<<<<< HEAD
,8 bit (byte),,16 bit (short integer),,32 bit,,64 bit (long integer),,Word size,,Arbitrarily precise (bignum)
,Signed,Unsigned,Signed,Unsigned,Signed,Unsigned,Signed,Unsigned,Signed,Unsigned,
Ada[1],range -2**7 .. 2**7 - 1Ada_range[j],range 0 .. 2**8 - 1Ada_range[j] or mod 2**8Ada_mod[k],range -2**15 .. 2**15 - 1Ada_range[j],range 0 .. 2**16 - 1Ada_range[j] or mod 2**16Ada_mod[k],range -2**31 .. 2**31 - 1Ada_range[j],range 0 .. 2**32 - 1Ada_range[j] or mod 2**32Ada_mod[k],range -2**63 .. 2**63 - 1Ada_range[j],mod 2**64Ada_mod[k],IntegerAda_range[j],range 0 .. 2**Integer'<wbr/>Size - 1Ada_range[j] or mod Integer'<wbr/>SizeAda_mod[k],
ALGOL 68 (variable-width),short short intCInt[c],rowspan=2 ,short intCInt[c],rowspan=2 ,intCInt[c],rowspan=2 ,long intCInt[c],rowspan=2 ,intCInt[c],,long long int a68[a]a68g[g]
,,bytes & bits,,,,,,,,,
C (C99 fixed-width),int8_t,uint8_t,int16_t,uint16_t,int32_t,uint32_t,int64_t,uint64_t,intptr_tCInt[c],size_tCInt[c],rowspan=5 
C++ (C++11 fixed-width),,,,,,,,,,,
C (C99 variable-width),signed char,unsigned char,shortCInt[c],unsigned shortCInt[c],longCInt[c],unsigned longCInt[c],long longCInt[c],unsigned long longCInt[c],intCInt[c],unsigned intCInt[c],
C++ (C++11 variable-width),,,,,,,,,,,
Objective-C (Cocoa),signed char or int8_t,unsigned char or uint8_t,short or int16_t,unsigned short or uint16_t,int or int32_t,unsigned int or uint32_t,long long or int64_t,unsigned long long or uint64_t,NSInteger or long,NSUInteger or unsigned long,
C#,sbyte,byte,short,ushort,int,uint,long,ulong,IntPtr,UIntPtr,System.Numerics<wbr/>.BigInteger (.NET 4.0)
Java,byte,,,charJava char[b],,,,,,,java.math<wbr/>.BigInteger
Go,int8,uint8 or byte,int16,uint16,int32,uint32,int64,uint64,int,uint,big.Int
Rust,i8,u8,i16,u16,i32,u32,i64,u64,isize,usize,
Swift,Int8,UInt8,Int16,UInt16,Int32,UInt32,Int64,UInt64,Int,UInt,
D,byte,ubyte,short,ushort,int,uint,long,ulong,,,BigInt
Common Lisp[2],(signed-byte 8),(unsigned-byte 8),(signed-byte 16),(unsigned-byte 16),(signed-byte 32),(unsigned-byte 32),(signed-byte 64),(unsigned-byte 64),,,bignum
Scheme,,,,,,,,,,,
ISLISP[3],,,,,,,,,,,bignum
Pascal (FPC),shortint,byte,smallint,word,longint,longword,int64,qword,integer,cardinal,
Visual Basic,,Byte,Integer,,Long,,colspan=2 ,rowspan=2 colspan=2 ,rowspan=1 ,,
Visual Basic .NET,SByte,,Short,UShort,Integer,UInteger,Long,ULong,System.Numerics<wbr/>.BigInteger (.NET 4.0),,
FreeBasic,Byte or Integer<8>,UByte or UInteger<8>,Short or Integer<16>,UShort or UInteger<16>,Long or Integer<32>,ULong or UInteger<32>,LongInt or Integer<64>,ULongInt or UInteger<64>,Integer,UInteger,
Python 2.x,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,int,,long,,,,
Python 3.x,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,int,,,,,
S-Lang,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,,,,,,
Fortran,INTEGER<wbr/>(KIND = n)Kinds[f],,INTEGER<wbr/>(KIND = n)Kinds[f],,INTEGER<wbr/>(KIND = n)Kinds[f],,INTEGER<wbr/>(KIND = n)Kinds[f],,,,
PHP,colspan=2 ,colspan=2 ,int PHP 32/64 bit long[m],,int PHP 32/64 bit long[m],,colspan=2 ,PHP bignum[e],,,
Perl 5,colspan=2 scalars[d],colspan=2 scalars[d],colspan=2 scalars[d],colspan=2 scalars[d],colspan=2 scalars[d],Math::BigInt,,,,,
Raku,int8,uint8,int16,uint16,int32,uint32,int64,uint64,Int,colspan=2 ,
Ruby,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,Fixnum,,Bignum,,,,
ErlangErlang_int[n],colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,integer(),,integer()Erlang_arb[o],,,,
Scala,Byte,,Short,CharScala Char[l],Int,,Long,,,,scala.math.BigInt
Seed7,,,,,,,integer,,,,bigInteger
Smalltalk,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,SmallIntegerSmalltalk[i],,LargeIntegerSmalltalk[i],,,,
Windows PowerShell,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,,,,,,
OCaml,colspan=2 ,colspan=2 ,int32,,int64,,int or nativeint,,open Big_int;; big_int,,
F#,sbyte,byte,int16,uint16,,int32 or int,uint32,uint64,nativeint,unativeint,bigint
Standard ML,,Word8.word,colspan=2 ,Int32.int,Word32.word,Int64.int,Word64.word,int,word,LargeInt.int or IntInf.int,
Haskell (GHC),«import Int» Int8,«import Word» Word8,«import Int» Int16,«import Word» Word16,«import Int» Int32,«import Word» Word32,«import Int» Int64,«import Word» Word64,Int,«import Word» Word,Integer
Eiffel,INTEGER_8,NATURAL_8,INTEGER_16,NATURAL_16,INTEGER_32,NATURAL_32,INTEGER_64,NATURAL_64,INTEGER,NATURAL,
COBOLCobol[h],BINARY-CHAR «SIGNED»,BINARY-CHAR UNSIGNED,BINARY-SHORT «SIGNED»,BINARY-SHORT UNSIGNED,BINARY-LONG «SIGNED»,BINARY-LONG UNSIGNED,BINARY-DOUBLE «SIGNED»,BINARY-DOUBLE UNSIGNED,,,
Mathematica,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,Integer,,,,,
Wolfram Language,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,colspan=2 ,Integer,,,,,
=======
! calling a function,basic/void function,value-returning function,required main function
Ada[1],foo «(parameters)»,procedure foo «(parameters)» is begin statements end foo,function foo «(parameters)» return type is begin statements end foo
ALGOL 68,foo«(parameters)»;,proc foo = «(parameters)» void: ( instructions );,proc foo = «(parameters)» rettype: ( instructions ...; retvalue );
APL,«parameters» foo parameters,foo?{ statements },foo?{ statements }
C (C99),foo(«parameters»),void foo(«parameters») { instructions },type foo(«parameters») { instructions ... return value; }
Objective-C,,,
C++ (STL),,,
Java,,,
D,,,
C#,,"Same as above; alternatively, if only one statement: void foo(«parameters») => statement;","Same as above; alternatively, if simple enough to be an expression: void foo(«parameters») => expression;"
JavaScript,,"function foo(«parameters») { instructions } or var foo = function («parameters») {instructions } or var foo = new Function («"parameter", ... ,"last parameter"» "instructions");",function foo(«parameters») { instructions ... return value; }
Go,,func foo(«parameters») { instructions },func foo(«parameters») type { instructions ... return value }
Swift,,func foo(«parameters») { instructions },func foo(«parameters») -> type { instructions ... return value }
Common Lisp,(foo «parameters»),(defun foo («parameters»)<dl><dd>instructions)</dd></dl> or (setf (symbol-function 'symbol)<dl><dd>function)</dd></dl>,(defun foo («parameters»)<dl><dd>...</dd><dd>value)</dd></dl>
Scheme,,(define (foo parameters) instructions) or (define foo (lambda (parameters) instructions)),(define (foo parameters) instructions... return_value) or (define foo (lambda (parameters) instructions... return_value))
ISLISP,,(defun foo («parameters»)<dl><dd>instructions)</dd></dl>,(defun foo («parameters»)<dl><dd>...</dd><dd>value)</dd></dl>
Pascal,foo«(parameters)»,procedure foo«(parameters)»; «forward;»forward declaration[a] «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «local function declarations» begin<dl><dd>instructions</dd></dl>end;,function foo«(parameters)»: type; «forward;»forward declaration[a] «label<dl><dd>label declarations»</dd></dl> «const<dl><dd>constant declarations»</dd></dl> «type<dl><dd>type declarations»</dd></dl> «var<dl><dd>variable declarations»</dd></dl> «local function declarations» begin<dl><dd> instructions; foo := value</dd></dl>end;
Visual Basic,Foo(«parameters»),Sub Foo«(parameters)»<dl><dd> instructions </dd></dl> End Sub,Function Foo«(parameters)»« As type»<dl><dd>instructions Foo = value</dd></dl>End Function
Visual Basic .NET,,,"Same as above; alternatively: Function Foo«(parameters)»« As type»<dl><dd>instructions Return value</dd></dl>End Function The As clause is not required if Option Strict is off. A type character may be used instead of the As clause. If control exits the function without a return value having been explicitly specified, the function returns the default value for the return type."
Xojo,,,
Python,foo(«parameters»),def foo(«parameters»): Tab instructions,def foo(«parameters»): Tab instructions Tab return value
S-Lang,foo(«parameters» «;qualifiers»),define foo («parameters») { instructions },define foo («parameters») { instructions ... return value; }
Fortran,foo («arguments») CALL sub_foo («arguments»)Fortran arguments[c],SUBROUTINE sub_foo («arguments») <dl><dd> instructions </dd></dl> END SUBROUTINEFortran arguments[c],type FUNCTION foo («arguments») <dl><dd> instructions ... foo = value </dd></dl> END FUNCTIONFortran arguments[c]
Forth,«parameters» FOO,: FOO « stack effect comment: ( before -- ) » <dl><dd> instructions </dd></dl> ;,: FOO « stack effect comment: ( before -- after ) » <dl><dd> instructions </dd></dl> ;
PHP,foo(«parameters»),function foo(«parameters») { instructions },function foo(«parameters») { instructions ... return value; }
Perl,foo(«parameters») or &foo«(parameters)»,sub foo { «my (parameters) = @_;» instructions },sub foo { «my (parameters) = @_;» instructions... «return» value; }
Raku,foo(«parameters») or &foo«(parameters)»,«multi »sub foo(parameters) { instructions },«our «type» »«multi »sub foo(parameters) { instructions... «return» value; }
Ruby,foo«(parameters)»,def foo«(parameters)» <dl><dd>instructions </dd></dl> end,def foo«(parameters)» <dl><dd>instructions «return» value </dd></dl> end
Rust,foo(«parameters»),fn foo(«parameters») { instructions },fn foo(«parameters») -> type { instructions }
Scala,foo«(parameters)»,def foo«(parameters)»«: Unit =» { instructions },def foo«(parameters)»«: type» = { instructions ... «return» value }
Windows PowerShell,foo «parameters»,function foo { instructions }; or function foo { «param(parameters)» instructions },function foo «(parameters)» { instructions … return value }; or function foo { «param(parameters)» instructions … return value }
Bash shell,foo «parameters»,<poem>function foo { 4instructions  or foo () { 4instructions </poem>,<poem>function foo { 4instructions 4return «exit_code»  or foo () { 4instructions 4return «exit_code» </poem>
,,"parameters $n ($1, $2, $3, ...) $@ (all parameters) $# (the number of parameters) $0 (this function name)",
OCaml,foo parameters,let «rec» foo parameters = instructions,let «rec» foo parameters = instructions... return_value
F#,,,
Standard ML,,fun foo parameters = ( instructions ),fun foo parameters = ( instructions... return_value )
Haskell,,foo parameters = do Tab instructions,foo parameters = return_value or foo parameters = do Tab instructions Tab return value
Eiffel,foo («parameters»),foo («parameters») <dl><dd>require <dl><dd>preconditions</dd></dl> do <dl><dd>instructions</dd></dl> ensure <dl><dd>postconditions</dd></dl> end</dd></dl>,foo («parameters»): type <dl><dd>require <dl><dd>preconditions</dd></dl> do <dl><dd>instructions</dd><dd>Result := value</dd></dl> ensure <dl><dd>postconditions</dd></dl> end</dd></dl>
CoffeeScript,foo(),foo = ->,foo = -> value
,foo parameters,foo = () ->,foo = ( parameters ) -> value
COBOL,CALL "foo" «USING parameters» <dl><dd> «exception-handling» </dd></dl> «END-CALL»COBOL calling programs[d],«IDENTIFICATION DIVISION.» PROGRAM-ID. foo. «other divisions...» PROCEDURE DIVISION «USING parameters». <dl><dd> instructions.</dd></dl>,«IDENTIFICATION DIVISION.» PROGRAM-ID/FUNCTION-ID. foo. «other divisions...» DATA DIVISION. «other sections...» LINKAGE SECTION. «parameter definitions...» variable-to-return definition «other sections...» PROCEDURE DIVISION «USING parameters» RETURNING variable-to-return. <dl><dd> instructions.</dd></dl>
,«FUNCTION» foo«(«parameters»)»,,
>>>>>>> ff4582384893868142f1b485861afa33c91d9c67

<<<<<<< HEAD
! while,do while,for i = first to last,foreach
Ada[1],while condition loop <dl><dd>statements</dd></dl> end loop,loop <dl><dd>statements</dd><dd>exit when not condition</dd></dl> end loop,for index in «reverse» [first .. last | discrete_type] loop <dl><dd>statements</dd></dl> end loop
ALGOL 68,«for index» «from first» «by increment» «to last» «while condition» do statements od,,
,«while condition» do statements od,«while statements; condition» do statements od,«for index» «from first» «by increment» «to last» do statements od
APL,:While condition<dl><dd>statements</dd></dl> :EndWhile,:Repeat <dl><dd>statements</dd></dl>:Until condition,:For var«s» :In list<dl><dd>statements</dd></dl> :EndFor
C (C99),instructions can be a single statement or a block in the form of: { statements } while (condition) instructions,do instructions while (condition);,for («type» i = first; i <= last; i++) instructions
Objective-C,,,
C++ (STL),,,
C#,,,
Java,,,
JavaScript,,,for (var i = first; i <= last; i++) instructions
PHP,,,"foreach (range(first, last) as $i) instructions or for ($i = first; $i <= last; $i++) instructions"
Windows PowerShell,,,for ($i = first; $i -le last; $i++) instructions
D,,,foreach (i; first ... last) instructions
Go,for condition { instructions },,for i := first; i <= last; i++ { instructions }
Swift,while condition { instructions },repeat { instructions } while condition (2.x) do { instructions } while condition (1.x),for i = first ... last { instructions } or for i = first ..< last+1 { instructions } or for var i = first; i <= last; i++ { instructions }
Perl,while (condition) { instructions } or until (notcondition) { instructions },do { instructions } while (condition) or do { instructions } until (notcondition),for«each» «$i» (first .. last) { instructions } or for ($i = first; $i <= last; $i++) { instructions }
Raku,while condition { instructions } or until notcondition { instructions },repeat { instructions } while condition or repeat { instructions } until notcondition,for first..last -> $i { instructions } or loop ($i = first; $i <=last; $i++) { instructions }
Ruby,while condition <dl><dd>instructions</dd></dl>end or until notcondition <dl><dd>instructions</dd></dl> end,begin <dl><dd>instructions</dd></dl> end while condition or begin <dl><dd>instructions</dd></dl> end until notcondition,for i in first..last <dl><dd>instructions</dd></dl> end or for i in first...last+1 <dl><dd>instructions</dd></dl> end or first.upto(last) { i instructions 
Bash shell,while condition ;do<dl><dd>instructions</dd></dl>done or until notcondition ;do<dl><dd>instructions</dd></dl> done,,for ((i = first; i <= last; ++i)) ; do<dl><dd>instructions</dd></dl>done
Scala,while (condition) { instructions },do { instructions } while (condition),for (i <- first to last «by 1») { instructions } or first to last «by 1» foreach (i => { instructions })
Smalltalk,conditionBlock whileTrue: <dl><dd>loopBlock</dd></dl>,loopBlock doWhile: <dl><dd>conditionBlock</dd></dl>,first to: last do: <dl><dd>loopBlock</dd></dl>
Common Lisp,(loop<dl><dd>while condition</dd><dd>do</dd><dd>instructions)</dd></dl> or (do () (notcondition)<dl><dd>instructions)</dd></dl>,(loop<dl><dd>do</dd><dd>instructions</dd><dd>while condition)</dd></dl>,(loop<dl><dd>for i from first to last «by 1»</dd><dd>do</dd><dd>instructions)</dd></dl> or (dotimes (i N)<dl><dd>instructions)</dd></dl> or (do ((i first (1+ i))) ((>= i last))<dl><dd>instructions)</dd></dl>
Scheme,(do () (notcondition) instructions) or (let loop () (if condition (begin instructions (loop)))),(let loop () (instructions (if condition (loop)))),(do ((i first (+ i 1))) ((>= i last)) instructions) or (let loop ((i first)) (if (< i last) (begin instructions (loop (+ i 1)))))
ISLISP,(while condition instructions),(tagbody loop instructions (if condition (go loop)),(for ((i first (+ i 1))) ((>= i last)) instructions)
Pascal,while condition do begin <dl><dd>instructions</dd></dl> end,repeat <dl><dd>instructions</dd></dl> until notcondition;,for i := first «step 1» to last do begin <dl><dd>instructions</dd></dl> end;step[a]
Visual Basic,Do While condition <dl><dd>instructions</dd></dl>Loop or Do Until notcondition <dl><dd>instructions</dd></dl>Loopor While condition instructions Wend (Visual Basic) End While (Visual Basic .NET),Do <dl><dd>instructions</dd></dl> Loop While condition or Do <dl><dd>instructions</dd></dl> Loop Until notcondition,i must be declared beforehand. For i = first To last« Step 1» <dl><dd>instructions</dd></dl> Next i
Visual Basic .NET,,,For i« As type» = first To last« Step 1» <dl><dd>instructions</dd></dl>Next« i»step[a]
Xojo,While condition <dl><dd>instructions</dd></dl>Wend,Do Until notcondition <dl><dd>instructions</dd></dl>Loop or Do <dl><dd>instructions</dd></dl> Loop Until notcondition,
Python,while condition : Tab instructions «else: Tab instructions»,,"for i in range(first, last+1): Tab instructions «else: Tab instructions»(Python 3.x) for i in xrange(first, last+1): Tab instructions «else: Tabinstructions»(Python 2.x)"
S-Lang,while (condition) { instructions } «then optional-block»,do { instructions } while (condition) «then optional-block»,for (i = first; i <= last; i++) { instructions } «then optional-block»
Fortran,DO WHILE (condition) <dl><dd> instructions</dd></dl> ENDDO,DO <dl><dd> instructions IF (condition) EXIT </dd></dl> ENDDO,"DO I = first,last <dl><dd> instructions </dd></dl> ENDDO"
Forth,BEGIN « instructions » condition WHILE instructions REPEAT,BEGIN instructions condition UNTIL,limit start DO instructions LOOP
OCaml,while condition do instructions done,,for i = first to last do instructions done
F#,while condition do Tab instructions,,for i = first to last do Tab instructions
Standard ML,while condition do ( instructions ),colspan=2 ,Array.app (fn item => instructions) array app (fn item => instructions) list
Haskell (GHC),colspan=2 ,Control.Monad.forM_ [first..last] (\i -> do instructions),Control.Monad.forM_ list (\item -> do instructions)
Eiffel,from <dl><dd>setup</dd></dl> until <dl><dd>condition</dd></dl> loop <dl><dd>instructions</dd></dl> end,,
CoffeeScript,while condition <dl><dd>expression</dd></dl>,rowspan=6 ,for i in [first..last] <dl><dd>expression</dd></dl>
,expression while condition,,
,while condition then expression,,
,until condition <dl><dd>expression</dd></dl>,,
,expression until condition,for i in [first..last] then expression,for item in set then expression
,until condition then expression,expression for i in [first..last],expression for item in set
COBOL,PERFORM procedure-1 «THROUGH procedure-2» ««WITH» TEST BEFORE» UNTIL conditionCOBOL THRU[c],PERFORM procedure-1 «THROUGH procedure-2» «WITH» TEST AFTER UNTIL conditionCOBOL THRU[c],PERFORM procedure-1 «THROUGH procedure-2» VARYING i FROM first BY increment UNTIL i > lastCOBOL GREATER THAN[d]
,PERFORM ««WITH» TEST BEFORE» UNTIL condition <dl><dd> expression </dd></dl> END-PERFORM,PERFORM «WITH» TEST AFTER UNTIL condition <dl><dd> expression </dd></dl> END-PERFORM,PERFORM VARYING i FROM first BY increment UNTIL i > last <dl><dd> expression </dd></dl> END-PERFORMCOBOL GREATER THAN[d]
=======
! if,else if,select case,conditional expression
Ada[1],if condition then <dl><dd>statements</dd></dl> «else <dl><dd>statements»</dd></dl> end if,if condition1 then <dl><dd>statements</dd></dl> elsif condition2 then <dl><dd>statements</dd></dl>... «else <dl><dd>statements»</dd></dl> end if,case expression is<dl><dd>when value_list1 => statements</dd><dd>when value_list2 => statements</dd></dl>...<dl><dd>«when others => statements» </dd></dl>end case
Seed7,if condition then <dl><dd>statements</dd></dl> «else <dl><dd>statements»</dd></dl> end if,if condition1 then <dl><dd>statements</dd></dl> elsif condition2 then <dl><dd>statements</dd></dl>... «else <dl><dd>statements»</dd></dl> end if,case expression of when set1 : statements ... «otherwise: statements» end case
Modula-2,if condition then <dl><dd>statements</dd></dl> «else <dl><dd>statements»</dd></dl> end,if condition1 then <dl><dd>statements</dd></dl> elsif condition2 then <dl><dd>statements</dd></dl>... «else <dl><dd>statements»</dd></dl> end,case expression of caseLabelList : statements | ... «else statements» end
ALGOL 68,if condition then statements «else statements» fi,if condition then statements elif condition then statements fi,"case switch in statements, statements«,... out statements» esac"
ALGOL 68 (brief form),statements «| statements» ),statements |: condition | statements ),"statements,... «| statements» )"
APL,:If condition <dl><dd>instructions</dd></dl> «:Else <dl><dd>instructions»</dd></dl>:EndIf,:If condition <dl><dd>instructions</dd></dl> :ElseIf condition <dl><dd>instructions</dd></dl> ... «:Else <dl><dd>instructions»</dd></dl> :EndIf,:Select expression :Case case1 <dl><dd>instructions</dd></dl> ... «:Else<dl><dd>instructions»</dd></dl>:EndSelect
C (C99) and: Objective-C C++ (STL) D Java JavaScript PHP,if (condition) instructions «else instructions» instructions can be a single statement or a block in the form of: { statements },if (condition) instructions else if (condition) instructions ... «else instructions» if (condition) instructions else { if (condition) instructions },switch (variable) {<dl><dd>case case1: instructions «break;» ... «default: instructions»</dd></dl>}
C#,if (condition) instructions «else instructions» instructions can be a single statement or a block in the form of: { statements },if (condition) instructions «else instructions» if (condition) instructions else if (condition) instructions ... «else instructions»,"All non-empty cases must end with a break or goto case statement (that is, they are not allowed to fall-through to the next case). The default case is not required to come last."
Windows PowerShell,if (condition) instructions «else instructions»,if (condition) { instructions } elseif (condition) { instructions } ... «else { instructions }»,switch (variable) { case1 { instructions «break;» } ... «default { instructions }»}
Go,if condition {instructions} «else {instructions}»,if condition {instructions} else if condition {instructions} ... «else {instructions}» or switch {<dl><dd>case condition: instructions ... «default: instructions»</dd></dl>},switch variable {<dl><dd>case case1: instructions ... «default: instructions»</dd></dl>}
Swift,if condition {instructions} «else {instructions}»,if condition {instructions} else if condition {instructions} ... «else {instructions}»,switch variable {<dl><dd>case case1: instructions ... «default: instructions»</dd></dl>}
Perl,if (condition) {instructions} «else {instructions}» or unless (notcondition) {instructions} «else {instructions}»,if (condition) {instructions} elsif (condition) {instructions} ... «else {instructions}» or unless (notcondition) {instructions} elsif (condition) {instructions} ... «else {instructions}»,use feature "switch"; ... given (variable) {<dl><dd>when (case1) { instructions } ... «default { instructions }»</dd></dl>}
Raku,if condition {instructions} «else {instructions}» or unless notcondition {instructions},if condition {instructions} elsif condition {instructions} ... «else {instructions},given variable {<dl><dd>when case1 { instructions } ... «default { instructions }»</dd></dl>}
Ruby,if condition <dl><dd>instructions</dd></dl> «else <dl><dd>instructions»</dd></dl>,if condition <dl><dd>instructions</dd></dl> elsif condition <dl><dd>instructions</dd></dl> ... «else <dl><dd>instructions»</dd></dl> end,case variable when case1 <dl><dd>instructions</dd></dl> ... «else<dl><dd>instructions»</dd></dl>end
Scala,if (condition) {instructions} «else {instructions}»,if (condition) {instructions} else if (condition) {instructions} ... «else {instructions}»,expression match {<dl><dd>case pattern1 => expression case pattern2 => expression ... «case _ => expression»</dd></dl>pattern matching[b]
Smalltalk,condition ifTrue: <dl><dd>trueBlock</dd></dl> «ifFalse: <dl><dd>falseBlock»</dd></dl> end,,
Common Lisp,(when condition <dl><dd>instructions)</dd></dl> or (unless condition <dl><dd>instructions)</dd></dl> or (if condition <dl><dd>(progn instructions)</dd><dd>«(progn instructions)»)</dd></dl>,(cond (condition1 instructions) <dl><dd>(condition2 instructions)</dd><dd>...</dd><dd>«(t instructions)»)</dd></dl>,(case expression<dl><dd>(case1 instructions)</dd><dd>(case2 instructions)</dd><dd>...</dd><dd>«(otherwise instructions)»)</dd></dl>
Scheme,(when conditioninstructions) or (if condition (begin instructions) «(begin instructions)»),(cond (condition1 instructions) (condition2 instructions) ... «(else instructions)»),(case (variable) ((case1) instructions) ((case2) instructions) ... «(else instructions)»)
ISLISP,(if condition <dl><dd>(progn instructions)</dd><dd>«(progn instructions)»)</dd></dl>,(cond (condition1 instructions) <dl><dd>(condition2 instructions)</dd><dd>...</dd><dd>«(t instructions)»)</dd></dl>,(case expression<dl><dd>(case1 instructions)</dd><dd>(case2 instructions)</dd><dd>...</dd><dd>«(t instructions)»)</dd></dl>
Pascal,if condition then begin <dl><dd>instructions</dd></dl> end «else begin<dl><dd>instructions</dd></dl>end»pascal semicolon[c],if condition then begin <dl><dd>instructions</dd></dl> end else if condition then begin<dl><dd>instructions</dd></dl> end ... «else begin<dl><dd>instructions</dd></dl> end»pascal semicolon[c],case variable of <dl><dd>case1: instructions ... «else: instructions»</dd></dl>endpascal semicolon[c]
Visual Basic,If condition Then <dl><dd>instructions</dd></dl> «Else <dl><dd>instructions»</dd></dl>End If Single-line: If we let instructions be: statement : statement : ... If condition Then instructions« Else instructions»,If condition Then<dl><dd>instructions</dd></dl> ElseIf condition Then<dl><dd>instructions</dd></dl> ... «Else <dl><dd>instructions»</dd></dl>End If Single-line: See note about C-like languages; the Else clause of a single-line If statement can contain another single-line If statement.,Select« Case» variable<dl><dd>Case case_pattern</dd>1<dl><dd>instructions</dd></dl><dd>...</dd><dd>«Case Else<dl><dd>instructions»</dd></dl></dd></dl>End Select
Visual Basic .NET,,,
Xojo,,,
Python python indent[a],if condition : Tab instructions «else: Tab instructions»,if condition : Tab instructions elif condition : Tab instructions ... «else: Tab instructions»,
S-Lang,if (condition) { instructions } «else { instructions }»,if (condition) { instructions } else if (condition) { instructions } ... «else { instructions }»,switch (variable) { case case1: instructions } { case case2: instructions } ...
Fortran,IF (condition) THEN <dl><dd> instructions </dd></dl> ELSE <dl><dd> instructions </dd></dl> ENDIF,IF (condition) THEN <dl><dd> instructions </dd></dl> ELSEIF (condition) THEN <dl><dd> instructions </dd></dl> ... ELSE <dl><dd> instructions </dd></dl> ENDIF,SELECT CASE(variable)<dl><dd> CASE (case1) <dl><dd> instructions </dd></dl> ... CASE DEFAULT <dl><dd> instructions </dd></dl> </dd></dl> END SELECT
Forth,condition IF instructions « ELSE instructions» THEN,condition IF instructions ELSE condition IF instructions THEN THEN,value CASE case OF instructions ENDOF case OF instructions ENDOF default instructions ENDCASE
OCaml,if condition then begin instructions end «else begin instructions end»,if condition then begin instructions end else if condition then begin instructions end ... «else begin instructions end»,match value with <dl><dd>pattern1 -> expression  pattern2 -> expression ... « _ -> expression»pattern matching[b]</dd></dl>
F#,Lightweight syntax mode: Either on a single line or with indentation as shown below: if condition then Tab instructions «else Tab instructions» Verbose syntax mode: Same as Standard ML (below).,Lightweight syntax mode: Either on a single line or with indentation as shown below: if condition then Tab instructions elif condition then Tab instructions ... «else Tab instructions» Verbose syntax mode: Same as Standard ML (below).,
Standard ML,if condition then «(»instructions «)» else «(» instructions «)»,if condition then «(»instructions «)» else if condition then «(» instructions «)» ... else «(» instructions «)»,pattern2 => expression ... « _ => expression»pattern matching[b]</dd></dl>
Haskell (GHC),if condition then expression else expression or when condition (do instructions) or unless notcondition (do instructions),condition = expression <dl><dd>| condition = expression | otherwise = expression</dd></dl>,case value of {<dl><dd>pattern1 -> expression; pattern2 ->expression; ... «_ -> expression»</dd></dl>pattern matching[b]
Bash shell,<poem>if condition-command; then 4expression «else 4expression» fi</poem>,<poem>if condition-command; then 4expression elif condition-command; then 4expression «else 4expression» fi</poem>,<poem>case "$variable" in "$condition1" ) 4command... "$condition2" ) 4command... esac</poem>
CoffeeScript,if condition then expression «else expression»,if condition then expression else if condition then expression «else expression»,switch expression <dl><dd>when condition then expression</dd></dl> <dl><dd>else expression</dd></dl>
,if condition <dl><dd>expression</dd></dl> «else <dl><dd>expression»</dd></dl>,if condition <dl><dd>expression</dd></dl> else if condition <dl><dd>expression</dd></dl> «else <dl><dd>expression»</dd></dl>,
,expression if condition,unless condition <dl><dd>expression</dd></dl> else unless condition <dl><dd>expression</dd></dl> «else <dl><dd>expression»</dd></dl>,switch expression <dl><dd>when condition <dl><dd>expression</dd></dl> «else <dl><dd>expression»</dd></dl></dd></dl>
,unless condition <dl><dd>expression</dd></dl> «else <dl><dd>expression»</dd></dl>,,
,expression unless condition,,
COBOL,IF condition «THEN» <dl><dd> expression </dd></dl> «ELSE <dl><dd> expression». </dd></dl>COBOL END-IF[d],,EVALUATE expression «ALSO expression...» <dl><dd> WHEN case-or-condition «ALSO case-or-condition...» <dl><dd> expression </dd></dl></dd></dl> <dl><dd> ... </dd></dl> <dl><dd>«WHEN OTHER <dl><dd> expression» </dd></dl></dd></dl> END-EVALUATE
! if,else if,select case,conditional expression
>>>>>>> ff4582384893868142f1b485861afa33c91d9c67

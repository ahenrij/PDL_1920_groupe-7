<<<<<<< HEAD
,variable,constant,type synonym
Ada[1],identifier : type« := initial_value»[e],identifier : constant type := final_value,subtype identifier is type
ALGOL 68,modename name« := initial_value»;,modename name = value;,mode synonym = modename;
C (C99),type name« = initial_value»;,enum{ name = value };,typedef type synonym;
Objective-C,,,
C++,,const type name = value;,
C#,"type name1« = initial_value», name2« = initial_value», ... ; or var name = initial_value;","const type name = value, name = value, ... ; or readonly type name = value, name = value, ... ;",using synonym = type;
D,type name« = initial_value»; or auto name = value;,const type name = value; or immutable type name = value;,alias type synonym;
Java,type name« = initial_value»;,final type name = value;,N/A
JavaScript,var name« = initial_value»; or let name« = initial_value»; (since ECMAScript 2015),const name = value; (since ECMAScript 2015),
Go,var name type« = initial_value» or name := initial_value,const name «type» = value,type synonym type
Rust[f],let mut name«: type»« = initial_value»; static mut NAME: type = value;,let name«: type»« = initial_value»; const NAME: type = value; static NAME: type = value;,type synonym = typename;
Swift,var name« : type»« = initial_value»,let name «: type» = value,typealias synonym = type
Common Lisp,(defparameter name initial-value) or (defvar name initial-value),(defconstant name value),(deftype synonym () 'type)
Scheme,(define name initial_value),,
ISLISP,(defglobal name initial_value) or (defdynamic name initial_value),(defconstant name value),N/A
Pascal[a],name: type« = initial_value»,name = value,synonym = type
Visual Basic,Dim name «As type»,"See notes to left. Constants use the same syntax, and: use Const instead of Dim have a restriction to only certain primitive types Const name1 «As type» = value, name2 «As type» = value, ...",
Visual Basic .NET[10],"The variable declaration syntax of VB.NET is surprisingly difficult to precisely describe. Given that there exist the identifier suffixes ("modifiers"): type_character, available as an alternative to an As clause for some primitive data types; nullable_specifier; and array_specifier; and that a modified_identifier is of the form identifier«type_character»«nullable_specifier»«array_specifier»; a modified_identifier_list is a comma-separated list of two or more occurrences of modified_identifier; and a declarator_list is a comma-separated list of declarators, which can be of the form identifier As object_creation_expression (object initializer declarator), modified_identifier« As non_array_type«array_rank_specifier»»« = initial_value» (single declarator), or modified_identifier_list« As «non_array_type««array_rank_specifier»» (multiple declarator); valid declaration statements are of the form Dim declarator_list, where, for the purpose of semantic analysis, to convert the declarator_list to a list of only single declarators: The As clauses of each multiple declarator is distributed over its modified_identifier_list The As New type... of each object initializer declarator is replaced with As type = New type... and for which, for each identifier, a type_character and As clause do not both appear; if an As clause is present, an array_rank_specifier does not appear both as a modification of the identifier and on the type of the As clause; an unmodified_type can be determined, by the rule that, if a type_character or As clause is present, unmodified_type is that specified by such construct, and that otherwise, either Option Infer must be on and the identifier must have an initializer, in which case unmodified_type is that of the initializer, or Option Strict must be off, in which case unmodified_type is Object; its final_type is its unmodified_type prepended before its modifiers; its final_type is a valid type; and if an initial_value is present, either Option Strict is on and initial_value has a widening conversion to final_type, or Option Strict is off and initial_value has a narrowing conversion to final_type. If Option Explicit is off, variables do not require explicit declaration; they are declared implicitly when used: name = initial_value",,Imports synonym = type
Xojo,Dim name «As type»« = initial_value»,,N/A
Python,name = initial_value,N/A,synonym = type[b]
CoffeeScript,,,N/A
S-Lang,name = initial_value;,,typedef struct {...} typename
Fortran,type name,"type, PARAMETER :: name = value",
PHP,$name = initial_value;,"define("name", value); const name = value (5.3+)",N/A
Perl,«my» $name« = initial_value»;[c],use constant name => value;,
Raku,«my «type»» $name« = initial_value»;[c],«my «type»» constant name = value;,::synonym ::= type
Ruby,name = initial_value,Name = value,synonym = type[b]
Scala,var name«: type» = initial_value,val name«: type» = value,type synonym = type
Windows PowerShell,«[type] »$name = initial_value,N/A,N/A
Bash shell,name=initial_value,N/A,N/A
OCaml,let name« : type ref» = ref value[d],let name «: type» = value,type synonym = type
F#,let mutable name« : type» = value,,
Standard ML,val name« : type ref» = ref value[d],val name «: type» = value,
Haskell,,«name::type;» name = value,type Synonym = type
Forth,VARIABLE name (in some systems use value VARIABLE name instead),value CONSTANT name,
COBOL,level-number name type clauses.,«0»1 name CONSTANT «AS» value.,level-number name type clauses «IS» TYPEDEF.
Mathematica,name=initial_value,N/A,N/A
=======
,throw,handler,assertion
Ada[1],raise exception_name «with string_expression»,begin statementsexception when exception_list1 => statements; when exception_list2 => statements; ... «when others => statements;»end[b],pragma Assert («Check =>» boolean_expression ««Message =>» string_expression») [function | procedure | entry] with Pre => boolean_expression Post => boolean_expression any_type with Type_Invariant => boolean_expression
APL,«string_expression» ?SIGNAL number_expression,:Trap number«s»_expression statements «:Case number«s»_expression statements» ... «:Else number«s»_expression statements»:EndTrap,«string_expression» ?SIGNAL 98/?~condition
C (C99),"longjmp(state, exception);",switch (setjmp(state)) { case 0: instructions break; case exception: instructions ... },assert(condition);
C++,throw exception;,try { instructions } catch «(exception)» { instructions } ...,
C#,,try { instructions } catch «(exception« name»)» { instructions } ... «finally { instructions }»,System.Diagnostics.Debug.Assert(condition);or System.Diagnostics.Trace.Assert(condition);
Java,,try { instructions } catch (exception) { instructions } ... «finally { instructions }»,assert condition «: description»;
JavaScript,,try { instructions } catch (exception) { instructions } «finally { instructions }»,?
D,,try { instructions } catch (exception) { instructions } ... «finally { instructions }»,assert(condition);
PHP,,try { instructions } catch (exception) { instructions } ... «finally { instructions }»,assert(condition);
S-Lang,,try { instructions } catch «exception» { instructions } ... «finally { instructions }»,?
Windows PowerShell,,trap «[exception]» { instructions } ... instructions or try { instructions } catch «[exception]» { instructions } ... «finally { instructions }»,[Debug]::Assert(condition)
Objective-C,@throw exception;,@try { instructions } @catch (exception) { instructions } ... «@finally { instructions }»,"NSAssert(condition, description);"
Swift,throw exception (2.x),do { try expression ... instructions } catch exception { instructions } ... (2.x),"assert(condition«, description»)"
Perl,die exception;,eval { instructions }; if ($@) { instructions },?
Raku,,try { instructions CATCH { when exception { instructions } ...}},?
Ruby,raise exception,begin instructions rescue exception instructions ... «else instructions» «ensure instructions» end,
Smalltalk,exception raise,instructionBlock on: exception do: handlerBlock,assert: conditionBlock
Common Lisp,(error "exception") or (error type arguments) or (error (make-condition type arguments)),(handler-case (progn instructions) (exception instructions) ...) or (handler-bind (condition (lambda instructions «invoke-restart restart args»)) ...)[a],(assert condition) or (assert condition «(place) «error»») or (check-type var type)
Scheme (R6RS),(raise exception),(guard (con (condition instructions) ...) instructions),?
ISLISP,(error "error-string" objects) or (signal-condition condition continuable),(with-handler handler form*),?
Pascal,raise Exception.Create(),try Except on E: exception do begin instructions end; end;,?
Visual Basic,Err.Raise ERRORNUMBER,With New Try: On Error Resume Next OneInstruction .Catch: On Error GoTo 0: Select Case .Number Case ERRORNUMBER instructions End Select: End With '*** Try class ***
Private mstrDescription As String
Private mlngNumber As Long
Public Sub Catch()

mstrDescription = Err.Description

mlngNumber = Err.Number

End Sub
Public Property Get Number() As Long

Number = mlngNumber

End Property
Public Property Get Description() As String

Description = mstrDescription
End Property
[12],Debug.Assert condition
Visual Basic .NET,Throw exceptionor Error errorcode,Try instructions Catch« name As exception»« When condition» instructions ... «Finally instructions» End Try,System.Diagnostics.Debug.Assert(condition)or System.Diagnostics.Trace.Assert(condition)
Xojo,Raise exception,Try instructions Catch «exception» instructions ... «Finally instructions» End Try,N/A
Python,raise exception,try: Tab ? instructions except «exception»: Tab ? instructions ... «else: Tab ? instructions» «finally: Tab ? instructions»,assert condition
Fortran,N/A,,
Forth,code THROW,xt CATCH ( code or 0 ),N/A
OCaml,raise exception,try expression with pattern -> expression ...,assert condition
F#,,try expression with pattern -> expression ... or try expression finally expression,
Standard ML,raise exception «arg»,expression handle pattern => expression ...,
Haskell (GHC),throw exception or throwError expression,catch tryExpression catchExpression or catchError tryExpression catchExpression,assert condition expression
COBOL,RAISE «EXCEPTION» exception,USE «AFTER» EXCEPTION OBJECT class-name. or USE «AFTER» EO class-name. or USE «AFTER» EXCEPTION CONDITION exception-name «FILE file-name». or USE «AFTER» EC exception-name «FILE file-name».,N/A
>>>>>>> ff4582384893868142f1b485861afa33c91d9c67

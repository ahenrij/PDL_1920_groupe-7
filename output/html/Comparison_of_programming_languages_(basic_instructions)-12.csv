<<<<<<< HEAD
,calling a function,basic/void function,value-returning function,required main function
Ada[1],foo «(parameters)»,procedure foo «(parameters)» is begin statements end foo,function foo «(parameters)» return type is begin statements end foo,N/A
ALGOL 68,foo«(parameters)»;,proc foo = «(parameters)» void: ( instructions );,proc foo = «(parameters)» rettype: ( instructions ...; retvalue );,N/A
APL,«parameters» foo parameters,foo?{ statements },foo?{ statements },N/A
C (C99),foo(«parameters»),void foo(«parameters») { instructions },type foo(«parameters») { instructions ... return value; },"«global declarations» int main(«int argc, char *argv[]») { instructions }"
Objective-C,,,,
C++ (STL),,,,
Java,,,,public static void main(String[] args) { instructions } or public static void main(String... args) { instructions }
D,,,,int main(«char[][] args») { instructions} or int main(«string[] args») { instructions} or void main(«char[][] args») { instructions} or void main(«string[] args») { instructions}
C#,,"Same as above; alternatively, if only one statement: void foo(«parameters») => statement;","Same as above; alternatively, if simple enough to be an expression: void foo(«parameters») => expression;","static void Main(«string[] args») method_body May instead return int. (starting with C# 7.1:) May return Task or Task<int>, and if so, may be async."
JavaScript,,"function foo(«parameters») { instructions } or var foo = function («parameters») {instructions } or var foo = new Function («"parameter", ... ,"last parameter"» "instructions");",function foo(«parameters») { instructions ... return value; },N/A
Go,,func foo(«parameters») { instructions },func foo(«parameters») type { instructions ... return value },func main() { instructions }
Swift,,func foo(«parameters») { instructions },func foo(«parameters») -> type { instructions ... return value },N/A
Common Lisp,(foo «parameters»),(defun foo («parameters») instructions) or (setf (symbol-function 'symbol) function),(defun foo («parameters») ... value),N/A
Scheme,,(define (foo parameters) instructions) or (define foo (lambda (parameters) instructions)),(define (foo parameters) instructions... return_value) or (define foo (lambda (parameters) instructions... return_value)),
ISLISP,,(defun foo («parameters») instructions),(defun foo («parameters») ... value),
Pascal,foo«(parameters)»,procedure foo«(parameters)»; «forward;»[a] «label label declarations» «const constant declarations» «type type declarations» «var variable declarations» «local function declarations» begin instructionsend;,function foo«(parameters)»: type; «forward;»[a] «label label declarations» «const constant declarations» «type type declarations» «var variable declarations» «local function declarations» begin instructions; foo := valueend;,program name; «label label declarations» «const constant declarations» «type type declarations» «var variable declarations» «function declarations» begin instructions end.
Visual Basic,Foo(«parameters»),Sub Foo«(parameters)» instructions End Sub,Function Foo«(parameters)»« As type» instructions Foo = valueEnd Function,Sub Main() instructionsEnd Sub
Visual Basic .NET,,,"Same as above; alternatively: Function Foo«(parameters)»« As type» instructions Return valueEnd Function The As clause is not required if Option Strict is off. A type character may be used instead of the As clause. If control exits the function without a return value having been explicitly specified, the function returns the default value for the return type.",Sub Main(««ByVal »args() As String») instructions End Subor Function Main(««ByVal »args() As String») As Integer instructionsEnd Function
Xojo,,,,
Python,foo(«parameters»),def foo(«parameters»): Tab ? instructions,def foo(«parameters»): Tab ? instructions Tab ? return value,N/A
S-Lang,foo(«parameters» «;qualifiers»),define foo («parameters») { instructions },define foo («parameters») { instructions ... return value; },public define slsh_main () { instructions }
Fortran,foo («arguments») CALL sub_foo («arguments»)[c],SUBROUTINE sub_foo («arguments») instructions END SUBROUTINE[c],type FUNCTION foo («arguments») instructions ... foo = value END FUNCTION[c],PROGRAM main instructions END PROGRAM
Forth,«parameters» FOO,: FOO « stack effect comment: ( before -- ) » instructions ;,: FOO « stack effect comment: ( before -- after ) » instructions ;,N/A
PHP,foo(«parameters»),function foo(«parameters») { instructions },function foo(«parameters») { instructions ... return value; },N/A
Perl,foo(«parameters») or &foo«(parameters)»,sub foo { «my (parameters) = @_;» instructions },sub foo { «my (parameters) = @_;» instructions... «return» value; },
Raku,foo(«parameters») or &foo«(parameters)»,«multi »sub foo(parameters) { instructions },«our «type» »«multi »sub foo(parameters) { instructions... «return» value; },
Ruby,foo«(parameters)»,def foo«(parameters)» instructions end,def foo«(parameters)» instructions «return» value end,
Rust,foo(«parameters»),fn foo(«parameters») { instructions },fn foo(«parameters») -> type { instructions },fn main() { instructions }
Scala,foo«(parameters)»,def foo«(parameters)»«: Unit =» { instructions },def foo«(parameters)»«: type» = { instructions ... «return» value },def main(args: Array[String]) { instructions }
Windows PowerShell,foo «parameters»,function foo { instructions }; or function foo { «param(parameters)» instructions },function foo «(parameters)» { instructions … return value }; or function foo { «param(parameters)» instructions … return value },N/A
Bash shell,foo «parameters»,function foo { instructions } or foo () { instructions },function foo { instructions return «exit_code» } or foo () { instructions return «exit_code» },
,,"parameters $n ($1, $2, $3, ...) $@ (all parameters) $# (the number of parameters) $0 (this function name)",,
OCaml,foo parameters,let «rec» foo parameters = instructions,let «rec» foo parameters = instructions... return_value,
F#,,,,[<EntryPoint>] let main args = instructions
Standard ML,,fun foo parameters = ( instructions ),fun foo parameters = ( instructions... return_value ),
Haskell,,foo parameters = do Tab ? instructions,foo parameters = return_value or foo parameters = do Tab ? instructions Tab ? return value,«main :: IO ()» main = do instructions
Eiffel,foo («parameters»),foo («parameters») require preconditions do instructions ensure postconditions end,foo («parameters»): type require preconditions do instructions Result := value ensure postconditions end,[b]
CoffeeScript,foo(),foo = ->,foo = -> value,N/A
,foo parameters,foo = () ->,foo = ( parameters ) -> value,
COBOL,CALL "foo" «USING parameters» «exception-handling» «END-CALL»[d],«IDENTIFICATION DIVISION.» PROGRAM-ID. foo. «other divisions...» PROCEDURE DIVISION «USING parameters». instructions.,«IDENTIFICATION DIVISION.» PROGRAM-ID/FUNCTION-ID. foo. «other divisions...» DATA DIVISION. «other sections...» LINKAGE SECTION. «parameter definitions...» variable-to-return definition «other sections...» PROCEDURE DIVISION «USING parameters» RETURNING variable-to-return. instructions.,N/A
,«FUNCTION» foo«(«parameters»)»,N/A,,
=======
,variable,constant,type synonym
Ada[1],identifier : type« := initial_value»[e],identifier : constant type := final_value,subtype identifier is type
ALGOL 68,modename name« := initial_value»;,modename name = value;,mode synonym = modename;
C (C99),type name« = initial_value»;,enum{ name = value };,typedef type synonym;
Objective-C,,,
C++,,const type name = value;,
C#,"type name1« = initial_value», name2« = initial_value», ... ; or var name = initial_value;","const type name = value, name = value, ... ; or readonly type name = value, name = value, ... ;",using synonym = type;
D,type name« = initial_value»; or auto name = value;,const type name = value; or immutable type name = value;,alias type synonym;
Java,type name« = initial_value»;,final type name = value;,N/A
JavaScript,var name« = initial_value»; or let name« = initial_value»; (since ECMAScript 2015),const name = value; (since ECMAScript 2015),
Go,var name type« = initial_value» or name := initial_value,const name «type» = value,type synonym type
Rust[f],let mut name«: type»« = initial_value»; static mut NAME: type = value;,let name«: type»« = initial_value»; const NAME: type = value; static NAME: type = value;,type synonym = typename;
Swift,var name« : type»« = initial_value»,let name «: type» = value,typealias synonym = type
Common Lisp,(defparameter name initial-value) or (defvar name initial-value),(defconstant name value),(deftype synonym () 'type)
Scheme,(define name initial_value),,
ISLISP,(defglobal name initial_value) or (defdynamic name initial_value),(defconstant name value),N/A
Pascal[a],name: type« = initial_value»,name = value,synonym = type
Visual Basic,Dim name «As type»,"See notes to left. Constants use the same syntax, and: use Const instead of Dim have a restriction to only certain primitive types Const name1 «As type» = value, name2 «As type» = value, ...",
Visual Basic .NET[10],"The variable declaration syntax of VB.NET is surprisingly difficult to precisely describe. Given that there exist the identifier suffixes ("modifiers"): type_character, available as an alternative to an As clause for some primitive data types; nullable_specifier; and array_specifier; and that a modified_identifier is of the form identifier«type_character»«nullable_specifier»«array_specifier»; a modified_identifier_list is a comma-separated list of two or more occurrences of modified_identifier; and a declarator_list is a comma-separated list of declarators, which can be of the form identifier As object_creation_expression (object initializer declarator), modified_identifier« As non_array_type«array_rank_specifier»»« = initial_value» (single declarator), or modified_identifier_list« As «non_array_type««array_rank_specifier»» (multiple declarator); valid declaration statements are of the form Dim declarator_list, where, for the purpose of semantic analysis, to convert the declarator_list to a list of only single declarators: The As clauses of each multiple declarator is distributed over its modified_identifier_list The As New type... of each object initializer declarator is replaced with As type = New type... and for which, for each identifier, a type_character and As clause do not both appear; if an As clause is present, an array_rank_specifier does not appear both as a modification of the identifier and on the type of the As clause; an unmodified_type can be determined, by the rule that, if a type_character or As clause is present, unmodified_type is that specified by such construct, and that otherwise, either Option Infer must be on and the identifier must have an initializer, in which case unmodified_type is that of the initializer, or Option Strict must be off, in which case unmodified_type is Object; its final_type is its unmodified_type prepended before its modifiers; its final_type is a valid type; and if an initial_value is present, either Option Strict is on and initial_value has a widening conversion to final_type, or Option Strict is off and initial_value has a narrowing conversion to final_type. If Option Explicit is off, variables do not require explicit declaration; they are declared implicitly when used: name = initial_value",,Imports synonym = type
Xojo,Dim name «As type»« = initial_value»,,N/A
Python,name = initial_value,N/A,synonym = type[b]
CoffeeScript,,,N/A
S-Lang,name = initial_value;,,typedef struct {...} typename
Fortran,type name,"type, PARAMETER :: name = value",
PHP,$name = initial_value;,"define("name", value); const name = value (5.3+)",N/A
Perl,«my» $name« = initial_value»;[c],use constant name => value;,
Raku,«my «type»» $name« = initial_value»;[c],«my «type»» constant name = value;,::synonym ::= type
Ruby,name = initial_value,Name = value,synonym = type[b]
Scala,var name«: type» = initial_value,val name«: type» = value,type synonym = type
Windows PowerShell,«[type] »$name = initial_value,N/A,N/A
Bash shell,name=initial_value,N/A,N/A
OCaml,let name« : type ref» = ref value[d],let name «: type» = value,type synonym = type
F#,let mutable name« : type» = value,,
Standard ML,val name« : type ref» = ref value[d],val name «: type» = value,
Haskell,,«name::type;» name = value,type Synonym = type
Forth,VARIABLE name (in some systems use value VARIABLE name instead),value CONSTANT name,
COBOL,level-number name type clauses.,«0»1 name CONSTANT «AS» value.,level-number name type clauses «IS» TYPEDEF.
Mathematica,name=initial_value,N/A,N/A
>>>>>>> ff4582384893868142f1b485861afa33c91d9c67

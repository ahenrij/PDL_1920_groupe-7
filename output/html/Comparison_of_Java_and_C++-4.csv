<<<<<<< HEAD
C++,Java
Extends C with object-oriented programming and generic programming. C code can most properly be used.,Strongly influenced by C++/C syntax.
"Compatible with C source code, except for a few corner cases.",Provides the Java Native Interface and recently Java Native Access as a way to directly call C/C++ code.
"Write once, compile anywhere (WOCA).","Write once, run anywhere/everywhere (WORA/WORE)."
"Allows procedural programming, functional programming, object-oriented programming, generic programming, and template metaprogramming. Favors a mix of paradigms.","Allows procedural programming, functional programming (since Java 8) and generic programming (since Java 5), but strongly encourages the object-oriented programming paradigm. Includes support for creating scripting languages."
Runs as native executable machine code for the target instruction set(s).,Runs on a virtual machine.
Provides object types and type names. Allows reflection via run-time type information (RTTI).,"Is reflective, allowing metaprogramming and dynamic code generation at runtime."
Has multiple binary compatibility standards (commonly Microsoft (for MSVC compiler) and Itanium/GNU (for almost all other compilers)).,"Has one binary compatibility standard, cross-platform for OS and compiler."
"Optional automated bounds checking (e.g., the at() method in vector and string containers).",All operations are required to be bound-checked by all compliant distributions of Java. HotSpot can remove bounds checking.
Native unsigned arithmetic support.,"Native unsigned arithmetic unsupported. Java 8 changes some of this, but aspects are unclear.[1]"
"Standardized minimum limits for all numerical types, but the actual sizes are implementation-defined. Standardized types are available via the standard library <cstdint>.",Standardized limits and sizes of all primitive types on all platforms.
"Pointers, references, and pass-by-value are supported for all types (primitive or user-defined).",All types (primitive types and reference types) are always passed by value.[2]
"Memory management can be done manually via new / delete, automatically by scope, or by smart pointers. Supports deterministic destruction of objects. Garbage collection ABI standardized in C++11, though compilers are not required to implement garbage collection.",Automatic garbage collection. Supports a non-deterministic finalize() method use of which is not recommended.[3]
Resource management can be done manually or by automatic lifetime-based resource management (RAII).,"Resource management must generally be done manually, or automatically via finalizers, though this is generally discouraged. Has try-with-resources for automatic scope-based resource management (version 7 onwards). It can also be done using the internal API sun.misc.Unsafe but that usage is highly discouraged and will be replaced by a public API in an upcoming Java version."
"Supports classes, structs (passive data structure (PDS) types), and unions, and can allocate them on the heap or the stack.",Classes are allocated on the heap. Java SE 6 optimizes with escape analysis to allocate some objects on the stack.
"Allows explicitly overriding types, and some implicit narrowing conversions (for compatibility with C).",Rigid type safety except for widening conversions.
"The C++ Standard Library was designed to have a limited scope and functions, but includes language support, diagnostics, general utilities, strings, locales, containers, algorithms, iterators, numerics, input/output, random number generators, regular expression parsing, threading facilities, type traits (for static type introspection) and Standard C Library. The Boost library offers more functions including network I/O. A rich amount of third-party libraries exist for GUI and other functions like: Adaptive Communication Environment (ACE), Crypto++, various XMPP Instant Messaging (IM) libraries,[4] OpenLDAP, Qt, gtkmm.","The standard library has grown with each release. By version 1.6, the library included support for locales, logging, containers and iterators, algorithms, GUI programming (but not using the system GUI), graphics, multi-threading, networking, platform security, introspection, dynamic class loading, blocking and non-blocking I/O. It provided interfaces or support classes for XML, XSLT, MIDI, database connectivity, naming services (e.g. LDAP), cryptography, security services (e.g. Kerberos), print services, and web services. SWT offered an abstraction for platform-specific GUIs, but was superseded by JavaFX in the latest releases ; allowing for graphics acceleration and CSS-themable UIs. Although it doesn't support any kind of "native platform look" support."
Operator overloading for most operators. Preserving meaning (semantics) is highly recommended.,Operators are not overridable. The language overrides + and += for the String class.
"Single and multiple inheritance of classes, including virtual inheritance.",Only supports single inheritance of classes.
Compile-time templates. Allows for Turing complete meta-programming.,"Generics are used to achieve basic type-parametrization, but they do not translate from source code to byte code due to the use of type erasure by the compiler."
"Function pointers, function objects, lambdas (in C++11), and interfaces.","Functions references, function objects and lambdas were added in Java 8. Classes (and interfaces, which are classes) can be passed as references as well through SomeClass.class"
No standard inline documentation mechanism. Third-party software (e.g. Doxygen) exists.,Extensive Javadoc documentation standard on all system classes and methods.
"const keyword for defining immutable variables and member functions that do not change the object. Const-ness is propagated as a means to enforce, at compile-time, correctness of the code with respect to mutability of objects (see const-correctness).","final provides a version of const, equivalent to type* const pointers for objects and const for primitive types. Immutability of object members achieved via read-only interfaces and object encapsulation."
Supports the goto statement.,Supports labels with loops and statement blocks. goto is a reserved keyword but is marked as "unused" in the Java specification.
"Source code can be written to be cross-platform (can be compiled for Windows, BSD, Linux, macOS, Solaris, etc., without modification) and written to use platform-specific features. Typically compiled into native machine code, must be recompiled for each target platform.","Compiled into Java bytecode for the JVM. Byte code is dependent on the Java platform, but is typically independent of operating system specific features."
=======
C++ Templates,Java Generics
"Classes, functions, aliases[17] and variables[18] can be templated.",Classes and methods can be genericized.
"Parameters can be variadic, of any type, integral value, character literal, or a class template.","Parameters can be any reference type, including boxed primitive types (i.e. Integer, Boolean...)."
"Separate instantiations of the class or function will be generated for each parameter-set when compiled. For class templates, only the member functions that are used will be instantiated.","One version of the class or function is compiled, works for all type parameters (via type-erasure)."
"Objects of a class template instantiated with different parameters will have different types at run time (i.e., distinct template instantiations are distinct classes).","Type parameters are erased when compiled; objects of a class with different type parameters are the same type at run time. It causes a different constructor. Because of this type erasure, it is not possible to overload methods using different instantiations of the generic class."
"Implementation of the class or function template must be visible within a translation unit in order to use it. This usually implies having the definitions in the header files or included in the header file. As of C++11, it is possible to use extern templates to separate compiling of some instantiations.",Signature of the class or function from a compiled class file is sufficient to use it.
Templates can be specialized—a separate implementation could be provided for a particular template parameter.,Generics cannot be specialized.
"Template parameters can have default arguments. Pre-C++11, this was allowed only for template classes, not functions.",Generic type parameters cannot have default arguments.
"Wildcards unsupported. Instead, return types are often available as nested typedefs. (Also, C++11 added keyword auto, which acts as a wildcard for any type that can be determined at compile time.)",Wildcards supported as type parameter.
"No direct support for bounding of type parameters, but metaprogramming provides this[19]","Supports bounding of type parameters with "extends" and "super" for upper and lower bounds, respectively; allows enforcement of relationships between type parameters."
Allows instantiation of an object with the type of the parameter type.,Precludes instantiation of an object with the type of the parameter type (except via reflection).
Type parameter of class template can be used for static methods and variables.,Type parameter of generic class cannot be used for static methods and variables.
Static variables unshared between classes and functions of different type parameters.,Static variables shared between instances of classes of different type parameters.
"Class and function templates do not enforce type relations for type parameters in their declaration. Use of an incorrect type parameter results in compiling failure, often generating an error message within the template code rather than in the user's code that invokes it. Proper use of templated classes and functions is dependent on proper documentation. Metaprogramming provides these features at the cost added effort. There was a proposition to solve this problem in C++11, so-called Concepts, it is planned for the next standard.",Generic classes and functions can enforce type relationships for type parameters in their declaration. Use of an incorrect type parameter results in a type error within the code that uses it. Operations on parametrized types in generic code are only allowed in ways that can be guaranteed to be safe by the declaration. This results in greater type safety at the cost of flexibility.
Templates are Turing-complete (see template metaprogramming).,Generics are also Turing-complete[20]
>>>>>>> ff4582384893868142f1b485861afa33c91d9c67
